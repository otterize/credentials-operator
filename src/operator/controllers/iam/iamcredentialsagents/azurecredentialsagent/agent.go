package azurecredentialsagent

import (
	"context"
	"github.com/otterize/credentials-operator/src/shared/apiutils"
	"github.com/otterize/intents-operator/src/shared/azureagent"
	"github.com/otterize/intents-operator/src/shared/errors"
	"github.com/samber/lo"
	"github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
)

const (
	// AzureAgentFinalizer indicates that cleanup on Azure workload identity is needed upon termination.
	AzureAgentFinalizer = "credentials-operator.otterize.com/azure-workload-identity"

	// AzureOtterizeServiceAccountLabel is used to label service accounts generated by the credentials-operator
	AzureOtterizeServiceAccountLabel = "credentials-operator.otterize.com/azure-service-account-managed"

	// AzureWorkloadIdentityClientIdAnnotation is used by the azure workload identity mechanism to link between service accounts and user assigned identities
	AzureWorkloadIdentityClientIdAnnotation = "azure.workload.identity/client-id"

	// OtterizeAzureWorkloadIdentityClientIdAnnotation is used to annotate the pod with its azure workload identity client ID, to trigger the azure workload identity webhook on it
	OtterizeAzureWorkloadIdentityClientIdAnnotation = "credentials-operator.otterize.com/azure-workload-identity-client-id"

	// AzureClientIDEnvVar is originally set by the Azure workload identity webhook, and is overridden by us to contain the generated client ID
	AzureClientIDEnvVar = "AZURE_CLIENT_ID"
)

type Agent struct {
	*azureagent.Agent
}

func NewAzureCredentialsAgent(azureAgent *azureagent.Agent) *Agent {
	return &Agent{azureAgent}
}

func (a *Agent) FinalizerName() string {
	return AzureAgentFinalizer
}

func (a *Agent) ServiceAccountLabel() string {
	return AzureOtterizeServiceAccountLabel
}

func (a *Agent) OnPodAdmission(ctx context.Context, pod *corev1.Pod, serviceAccount *corev1.ServiceAccount, dryRun bool) error {
	logger := logrus.WithFields(logrus.Fields{"serviceAccount": serviceAccount.Name, "namespace": serviceAccount.Namespace})

	if !dryRun {
		// get or create the user assigned identity, ensuring the identity & federated credentials are in-place
		identity, err := a.GetOrCreateUserAssignedIdentity(ctx, serviceAccount.Namespace, serviceAccount.Name)
		if err != nil {
			return errors.Errorf("failed to create user assigned identity: %w", err)
		}

		clientId := *identity.Properties.ClientID

		logger.WithField("identity", *identity.Name).WithField("clientId", clientId).
			Info("Annotating service account with managed identity client ID")

		apiutils.AddAnnotation(serviceAccount, AzureWorkloadIdentityClientIdAnnotation, clientId)
		// we additionally annotate the pod with the client ID to trigger the azure workload identity webhook on it
		// (the content of the annotation is not really important, we just need to trigger _some_ modification).
		apiutils.AddAnnotation(pod, OtterizeAzureWorkloadIdentityClientIdAnnotation, clientId)

		// update the pod's containers with the new client ID
		// it would be great if the azure workload identity webhook could do this for us, but it doesn't,
		// because it had already set its client ID to an empty string on its first invocation,
		// before we had a chance to set it on the service account.
		pod.Spec.InitContainers = mutateContainers(pod.Spec.InitContainers, clientId)
		pod.Spec.Containers = mutateContainers(pod.Spec.Containers, clientId)
	}

	return nil
}

func mutateContainers(containers []corev1.Container, clientId string) []corev1.Container {
	return lo.Map(containers, func(container corev1.Container, _ int) corev1.Container {
		container.Env = lo.Map(container.Env, func(env corev1.EnvVar, _ int) corev1.EnvVar {
			if env.Name == AzureClientIDEnvVar {
				logrus.WithField("container", container.Name).WithField("envVar", env.Name).WithField("value", clientId).
					Debug("Updating container env var")
				env.Value = clientId
			}
			return env
		})
		return container
	})
}

func (a *Agent) OnPodUpdate(ctx context.Context, pod *corev1.Pod, serviceAccount *corev1.ServiceAccount) (updated bool, requeue bool, err error) {
	return false, false, nil
}

func (a *Agent) OnServiceAccountUpdate(ctx context.Context, serviceAccount *corev1.ServiceAccount) (updated bool, requeue bool, err error) {
	return false, false, nil
}

func (a *Agent) OnServiceAccountTermination(ctx context.Context, serviceAccount *corev1.ServiceAccount) error {
	return a.DeleteUserAssignedIdentity(ctx, serviceAccount.Namespace, serviceAccount.Name)
}
