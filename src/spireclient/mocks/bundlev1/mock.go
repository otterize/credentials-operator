// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/spiffe/spire-api-sdk/proto/spire/api/server/bundle/v1 (interfaces: BundleClient)

// Package mock_v1 is a generated GoMock package.
package mock_v1

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	bundlev1 "github.com/spiffe/spire-api-sdk/proto/spire/api/server/bundle/v1"
	types "github.com/spiffe/spire-api-sdk/proto/spire/api/types"
	grpc "google.golang.org/grpc"
)

// MockBundleClient is a mock of BundleClient interface.
type MockBundleClient struct {
	ctrl     *gomock.Controller
	recorder *MockBundleClientMockRecorder
}

// MockBundleClientMockRecorder is the mock recorder for MockBundleClient.
type MockBundleClientMockRecorder struct {
	mock *MockBundleClient
}

// NewMockBundleClient creates a new mock instance.
func NewMockBundleClient(ctrl *gomock.Controller) *MockBundleClient {
	mock := &MockBundleClient{ctrl: ctrl}
	mock.recorder = &MockBundleClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBundleClient) EXPECT() *MockBundleClientMockRecorder {
	return m.recorder
}

// AppendBundle mocks base method.
func (m *MockBundleClient) AppendBundle(arg0 context.Context, arg1 *bundlev1.AppendBundleRequest, arg2 ...grpc.CallOption) (*types.Bundle, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendBundle", varargs...)
	ret0, _ := ret[0].(*types.Bundle)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AppendBundle indicates an expected call of AppendBundle.
func (mr *MockBundleClientMockRecorder) AppendBundle(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendBundle", reflect.TypeOf((*MockBundleClient)(nil).AppendBundle), varargs...)
}

// BatchCreateFederatedBundle mocks base method.
func (m *MockBundleClient) BatchCreateFederatedBundle(arg0 context.Context, arg1 *bundlev1.BatchCreateFederatedBundleRequest, arg2 ...grpc.CallOption) (*bundlev1.BatchCreateFederatedBundleResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchCreateFederatedBundle", varargs...)
	ret0, _ := ret[0].(*bundlev1.BatchCreateFederatedBundleResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchCreateFederatedBundle indicates an expected call of BatchCreateFederatedBundle.
func (mr *MockBundleClientMockRecorder) BatchCreateFederatedBundle(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchCreateFederatedBundle", reflect.TypeOf((*MockBundleClient)(nil).BatchCreateFederatedBundle), varargs...)
}

// BatchDeleteFederatedBundle mocks base method.
func (m *MockBundleClient) BatchDeleteFederatedBundle(arg0 context.Context, arg1 *bundlev1.BatchDeleteFederatedBundleRequest, arg2 ...grpc.CallOption) (*bundlev1.BatchDeleteFederatedBundleResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchDeleteFederatedBundle", varargs...)
	ret0, _ := ret[0].(*bundlev1.BatchDeleteFederatedBundleResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchDeleteFederatedBundle indicates an expected call of BatchDeleteFederatedBundle.
func (mr *MockBundleClientMockRecorder) BatchDeleteFederatedBundle(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchDeleteFederatedBundle", reflect.TypeOf((*MockBundleClient)(nil).BatchDeleteFederatedBundle), varargs...)
}

// BatchSetFederatedBundle mocks base method.
func (m *MockBundleClient) BatchSetFederatedBundle(arg0 context.Context, arg1 *bundlev1.BatchSetFederatedBundleRequest, arg2 ...grpc.CallOption) (*bundlev1.BatchSetFederatedBundleResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchSetFederatedBundle", varargs...)
	ret0, _ := ret[0].(*bundlev1.BatchSetFederatedBundleResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchSetFederatedBundle indicates an expected call of BatchSetFederatedBundle.
func (mr *MockBundleClientMockRecorder) BatchSetFederatedBundle(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchSetFederatedBundle", reflect.TypeOf((*MockBundleClient)(nil).BatchSetFederatedBundle), varargs...)
}

// BatchUpdateFederatedBundle mocks base method.
func (m *MockBundleClient) BatchUpdateFederatedBundle(arg0 context.Context, arg1 *bundlev1.BatchUpdateFederatedBundleRequest, arg2 ...grpc.CallOption) (*bundlev1.BatchUpdateFederatedBundleResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchUpdateFederatedBundle", varargs...)
	ret0, _ := ret[0].(*bundlev1.BatchUpdateFederatedBundleResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchUpdateFederatedBundle indicates an expected call of BatchUpdateFederatedBundle.
func (mr *MockBundleClientMockRecorder) BatchUpdateFederatedBundle(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchUpdateFederatedBundle", reflect.TypeOf((*MockBundleClient)(nil).BatchUpdateFederatedBundle), varargs...)
}

// CountBundles mocks base method.
func (m *MockBundleClient) CountBundles(arg0 context.Context, arg1 *bundlev1.CountBundlesRequest, arg2 ...grpc.CallOption) (*bundlev1.CountBundlesResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CountBundles", varargs...)
	ret0, _ := ret[0].(*bundlev1.CountBundlesResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountBundles indicates an expected call of CountBundles.
func (mr *MockBundleClientMockRecorder) CountBundles(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountBundles", reflect.TypeOf((*MockBundleClient)(nil).CountBundles), varargs...)
}

// GetBundle mocks base method.
func (m *MockBundleClient) GetBundle(arg0 context.Context, arg1 *bundlev1.GetBundleRequest, arg2 ...grpc.CallOption) (*types.Bundle, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetBundle", varargs...)
	ret0, _ := ret[0].(*types.Bundle)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBundle indicates an expected call of GetBundle.
func (mr *MockBundleClientMockRecorder) GetBundle(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBundle", reflect.TypeOf((*MockBundleClient)(nil).GetBundle), varargs...)
}

// GetFederatedBundle mocks base method.
func (m *MockBundleClient) GetFederatedBundle(arg0 context.Context, arg1 *bundlev1.GetFederatedBundleRequest, arg2 ...grpc.CallOption) (*types.Bundle, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetFederatedBundle", varargs...)
	ret0, _ := ret[0].(*types.Bundle)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFederatedBundle indicates an expected call of GetFederatedBundle.
func (mr *MockBundleClientMockRecorder) GetFederatedBundle(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFederatedBundle", reflect.TypeOf((*MockBundleClient)(nil).GetFederatedBundle), varargs...)
}

// ListFederatedBundles mocks base method.
func (m *MockBundleClient) ListFederatedBundles(arg0 context.Context, arg1 *bundlev1.ListFederatedBundlesRequest, arg2 ...grpc.CallOption) (*bundlev1.ListFederatedBundlesResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFederatedBundles", varargs...)
	ret0, _ := ret[0].(*bundlev1.ListFederatedBundlesResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFederatedBundles indicates an expected call of ListFederatedBundles.
func (mr *MockBundleClientMockRecorder) ListFederatedBundles(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFederatedBundles", reflect.TypeOf((*MockBundleClient)(nil).ListFederatedBundles), varargs...)
}

// PublishJWTAuthority mocks base method.
func (m *MockBundleClient) PublishJWTAuthority(arg0 context.Context, arg1 *bundlev1.PublishJWTAuthorityRequest, arg2 ...grpc.CallOption) (*bundlev1.PublishJWTAuthorityResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PublishJWTAuthority", varargs...)
	ret0, _ := ret[0].(*bundlev1.PublishJWTAuthorityResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PublishJWTAuthority indicates an expected call of PublishJWTAuthority.
func (mr *MockBundleClientMockRecorder) PublishJWTAuthority(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishJWTAuthority", reflect.TypeOf((*MockBundleClient)(nil).PublishJWTAuthority), varargs...)
}
